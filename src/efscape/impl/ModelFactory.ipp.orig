// __COPYRIGHT_START__
// Package Name : efscape
// File Name : ModelFactory.ipp
// Copyright (C) 2006-2009 by Jon C. Cline
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Bugs, comments, and questions can be sent to clinej@stanfordalumni.org
// __COPYRIGHT_END__
#ifndef EFSCAPE_IMPL_MODELFACTORY_IPP
#define EFSCAPE_IMPL_MODELFACTORY_IPP

#include <efscape/impl/ModelFactory.hpp>

#include <efscape/impl/ModelHomeI.hh>
#include <efscape/utils/type.hpp>

// boost serialization definitions
#include <boost/serialization/version.hpp>
#include <boost/serialization/type_info_implementation.hpp>

#include <iostream>

namespace efscape {

  namespace impl {

    /**
     * default constructor
     *
     * @tparam BaseType base type of factory
     */
    template <class BaseType>
    ModelFactoryTmpl<BaseType>::ModelFactoryTmpl() {}

    /**
     * destructor
     *
     * @tparam BaseType base type of factory
     */
    template <class BaseType>
    ModelFactoryTmpl<BaseType>::~ModelFactoryTmpl() {}

    /**
     * Returns a model object of type <acp_name>.
     *
     * @tparam BaseType base type of factory
     * @param acp_name model type name
     * @returns handle to new model object
     */
    template <class BaseType>
    BaseType* ModelFactoryTmpl<BaseType>::CreateModel(const char* acp_name)
    {
      try {
	return mC_factory.CreateObject(acp_name);
      }
      catch(...) {
	LOG4CXX_ERROR(ModelHomeI::getLogger(),
		      "ModelFactoryTmpl<>::CreateModel(" << acp_name
		      << "): class not found");
      }
      return 0;
    }

    /**
     * Lists all models in the repository .
     *
     * @tparam BaseType base type of factory
     * @param aC1r_ModelSet selected subset of models
     */
    template <class BaseType>
    void
    ModelFactoryTmpl<BaseType>::ListModels(std::set<std::string>&
					   aCr_ModelNames)
    {
      std::map< std::string, ModelInfo >::iterator iModel;
      for (iModel = mCC_ModelInfoMap.begin(); iModel != mCC_ModelInfoMap.end();
	   iModel++) {
	BaseType* lCp_model = CreateModel(iModel->first.c_str());
	if (lCp_model == NULL) {
	  LOG4CXX_ERROR(ModelHomeI::getLogger(),
			"Unable to create model<" << iModel->first << ">");
	  continue;
	}
	aCr_ModelNames.insert(iModel->first);
      }	// for (iModel = ...

    }	// ModelFactoryTmpl<>::ListModels(std::set<std::string>)

    /**
     * Lists models in the repository that match the specified criteria.
     *
     * @tparam BaseType base type of factory
     * @param aC1r_ModelSet selected subset of models
     * @param aCr_ModelMatch selection criteria
     */
    template <class BaseType>
    void
    ModelFactoryTmpl<BaseType>::ListModels(std::set<std::string>&
					   aCr_ModelNames,
					   bool(*aFp_ModelMatch)
					   (const BaseType*) )
    {
      std::map< std::string, ModelInfo >::iterator iModel;
      for (iModel = mCC_ModelInfoMap.begin(); iModel != mCC_ModelInfoMap.end();
	   iModel++) {
	BaseType* lCp_model = CreateModel(iModel->first.c_str());
	if (lCp_model == NULL) {
	  LOG4CXX_ERROR(ModelHomeI::getLogger(),
			"Unable to create model<" << iModel->first << ">");
	  continue;
	}
	if ( (*aFp_ModelMatch)(lCp_model))
	  aCr_ModelNames.insert(iModel->first);
      }	// for (iModel = ...

    }	// ModelFactoryTmpl<>::ListModels(std::set<std::string>,...)

    /**
     * Returns model info for model <acp_classname>.
     *
     * @tparam BaseType base type of factory
     * @param acp_classname model class name
     * @returns model info for model <acp_classname>
     */
    template <class BaseType>
    ModelInfo
    ModelFactoryTmpl<BaseType>::getModelInfo(const char* acp_classname)
    {
      std::map< std::string, ModelInfo >::iterator iModel;
      if ( (iModel = mCC_ModelInfoMap.find(acp_classname) ) !=
	   mCC_ModelInfoMap.end() )
	return iModel->second;
      
      return ModelInfo();

    } // ModelFactoryTmpl<>::getModelInfo(const char*)

    /**
     * Registers a model in the factory repository and model info repository.
     *
     * @tparam BaseType base model type
     * @tparam DerivedType derived model type
     * @param acp_info class info
     * @param acp_library_name library this class belongs to
     * @returns whether registration was successful 
     */
    template <class BaseType> template<class DerivedType>
    bool
    ModelFactoryTmpl<BaseType>::RegisterModel(const char* acp_info)
    {
      const char* lcp_library_name = "efscapeimpl";
      RegisterModel((const char*)acp_info,(const char*)lcp_library_name);
    }

    /**
     * Registers a model in the factory repository and model info repository.
     *
     * @tparam BaseType base model type
     * @tparam DerivedType derived model type
     * @param acp_info class info
     * @param acp_library_name library this class belongs to
     * @returns whether registration was successful 
     */
    template <class BaseType> template<class DerivedType>
    bool
    ModelFactoryTmpl<BaseType>::RegisterModel(const char* acp_info,
					      const char*
					      acp_library_name)
    {
      DerivedType* lCp_proto = new DerivedType();
      std::string lC_id = efscape::utils::type<DerivedType>(*lCp_proto);
      delete lCp_proto;

      int li_version = boost::serialization::version<DerivedType>::value;
      
      std::cout << "Registering model class <" << lC_id
		<< "> of version " << li_version << "...\n";

      // insert model info
      mCC_ModelInfoMap[lC_id] = ModelInfo(li_version,
					  acp_info,
					  acp_library_name);

      // register model
      return ( mC_factory.Register(lC_id, createModel<BaseType,DerivedType>) );
    }

  } // namespace impl

} // namespace efscape

#endif	// #ifndef EFSCAPE_IMPL_MODELFACTORY_IPP
