diff -Naur repast_hpc-2.3.0/cmake/Modules/FindNetCDF.cmake repast_hpc-2.3.0~patched/cmake/Modules/FindNetCDF.cmake
--- repast_hpc-2.3.0/cmake/Modules/FindNetCDF.cmake	1969-12-31 19:00:00.000000000 -0500
+++ repast_hpc-2.3.0~patched/cmake/Modules/FindNetCDF.cmake	2019-01-27 20:42:27.000000000 -0500
@@ -0,0 +1,71 @@
+# - Find NetCDF
+# Find the native NetCDF includes and library
+#
+#  NETCDF_INCLUDES    - where to find netcdf.h, etc
+#  NETCDF_LIBRARIES   - Link these libraries when using NetCDF
+#  NETCDF_FOUND       - True if NetCDF found including required interfaces (see below)
+#
+# Your package can require certain interfaces to be FOUND by setting these
+#
+#  NETCDF_CXX         - require the C++ interface and link the C++ library
+#  NETCDF_F77         - require the F77 interface and link the fortran library
+#  NETCDF_F90         - require the F90 interface and link the fortran library
+#
+# The following are not for general use and are included in
+# NETCDF_LIBRARIES if the corresponding option above is set.
+#
+#  NETCDF_LIBRARIES_C    - Just the C interface
+#  NETCDF_LIBRARIES_CXX  - C++ interface, if available
+#  NETCDF_LIBRARIES_F77  - Fortran 77 interface, if available
+#  NETCDF_LIBRARIES_F90  - Fortran 90 interface, if available
+#
+# Normal usage would be:
+#  set (NETCDF_F90 "YES")
+#  find_package (NetCDF REQUIRED)
+#  target_link_libraries (uses_f90_interface ${NETCDF_LIBRARIES})
+#  target_link_libraries (only_uses_c_interface ${NETCDF_LIBRARIES_C})
+
+if (NETCDF_INCLUDES AND NETCDF_LIBRARIES)
+  # Already in cache, be silent
+  set (NETCDF_FIND_QUIETLY TRUE)
+endif (NETCDF_INCLUDES AND NETCDF_LIBRARIES)
+
+find_path (NETCDF_INCLUDES netcdf.h
+  HINTS NETCDF_DIR ENV NETCDF_DIR)
+
+find_library (NETCDF_LIBRARIES_C       NAMES netcdf)
+mark_as_advanced(NETCDF_LIBRARIES_C)
+
+set (NetCDF_has_interfaces "YES") # will be set to NO if we're missing any interfaces
+set (NetCDF_libs "${NETCDF_LIBRARIES_C}")
+
+get_filename_component (NetCDF_lib_dirs "${NETCDF_LIBRARIES_C}" PATH)
+
+macro (NetCDF_check_interface lang header libs)
+  if (NETCDF_${lang})
+    find_path (NETCDF_INCLUDES_${lang} NAMES ${header}
+      HINTS "${NETCDF_INCLUDES}" NO_DEFAULT_PATH)
+    find_library (NETCDF_LIBRARIES_${lang} NAMES ${libs}
+      HINTS "${NetCDF_lib_dirs}" NO_DEFAULT_PATH)
+    mark_as_advanced (NETCDF_INCLUDES_${lang} NETCDF_LIBRARIES_${lang})
+    if (NETCDF_INCLUDES_${lang} AND NETCDF_LIBRARIES_${lang})
+      list (INSERT NetCDF_libs 0 ${NETCDF_LIBRARIES_${lang}}) # prepend so that -lnetcdf is last
+    else (NETCDF_INCLUDES_${lang} AND NETCDF_LIBRARIES_${lang})
+      set (NetCDF_has_interfaces "NO")
+      message (STATUS "Failed to find NetCDF interface for ${lang}")
+    endif (NETCDF_INCLUDES_${lang} AND NETCDF_LIBRARIES_${lang})
+  endif (NETCDF_${lang})
+endmacro (NetCDF_check_interface)
+
+NetCDF_check_interface (CXX netcdfcpp.h netcdf_c++)
+NetCDF_check_interface (F77 netcdf.inc  netcdff)
+NetCDF_check_interface (F90 netcdf.mod  netcdff)
+
+set (NETCDF_LIBRARIES "${NetCDF_libs}" CACHE STRING "All NetCDF libraries required for interface level")
+
+# handle the QUIETLY and REQUIRED arguments and set NETCDF_FOUND to TRUE if
+# all listed variables are TRUE
+include (FindPackageHandleStandardArgs)
+find_package_handle_standard_args (NetCDF DEFAULT_MSG NETCDF_LIBRARIES NETCDF_INCLUDES NetCDF_has_interfaces)
+
+mark_as_advanced (NETCDF_LIBRARIES NETCDF_INCLUDES)
\ No newline at end of file
diff -Naur repast_hpc-2.3.0/src/CMakeLists.txt repast_hpc-2.3.0~patched/src/CMakeLists.txt
--- repast_hpc-2.3.0/src/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/CMakeLists.txt	2019-01-27 20:22:33.000000000 -0500
@@ -0,0 +1,303 @@
+project(repast_hpc_project)
+
+cmake_minimum_required(VERSION 3.0)
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/../cmake/Modules/")
+
+set(rhpc_headers
+	repast_hpc/AgentId.h
+	repast_hpc/AgentImporterExporter.h
+	repast_hpc/AgentRequest.h
+	repast_hpc/AgentStatus.h
+	repast_hpc/BaseGrid.h
+	repast_hpc/CartesianTopology.h
+	repast_hpc/Context.h
+	repast_hpc/DataSet.h
+	repast_hpc/DiffusionLayerND.h
+	repast_hpc/DirectedVertex.h
+	repast_hpc/Edge.h
+	repast_hpc/Graph.h
+	repast_hpc/Grid.h
+	repast_hpc/Grid2DQuery.h
+	repast_hpc/GridComponents.h
+	repast_hpc/GridDimensions.h
+	repast_hpc/Moore2DGridQuery.h
+	repast_hpc/MultipleOccupancy.h
+	repast_hpc/NCDataSet.h
+	repast_hpc/NCDataSetBuilder.h
+	repast_hpc/NCDataSource.h
+	repast_hpc/NCReducibleDataSource.h
+	repast_hpc/NetworkBuilder.h
+	repast_hpc/Point.h
+	repast_hpc/Projection.h
+	repast_hpc/Properties.h
+	repast_hpc/Random.h
+	repast_hpc/ReducibleDataSource.h
+	repast_hpc/RelativeLocation.h
+	repast_hpc/RelativeLocationMap.h
+	repast_hpc/RepastErrors.h
+	repast_hpc/RepastProcess.h
+	repast_hpc/SRManager.h
+	repast_hpc/SVDataSet.h
+	repast_hpc/SVDataSetBuilder.h
+	repast_hpc/SVDataSource.h
+	repast_hpc/Schedule.h
+	repast_hpc/SharedBaseGrid.h
+	repast_hpc/SharedContext.h
+	repast_hpc/SharedContinuousSpace.h
+	repast_hpc/SharedDiscreteSpace.h
+	repast_hpc/SharedNetwork.h
+	repast_hpc/SharedSpaces.h
+	repast_hpc/SingleOccupancy.h
+	repast_hpc/Spaces.h
+	repast_hpc/TDataSource.h
+	repast_hpc/UndirectedVertex.h
+	repast_hpc/Utilities.h
+	repast_hpc/VN2DGridQuery.h
+	repast_hpc/ValueLayer.h
+	repast_hpc/ValueLayerND.h
+	repast_hpc/Variable.h
+	repast_hpc/Vertex.h
+	repast_hpc/initialize_random.h
+	repast_hpc/io.h
+	repast_hpc/logger.h
+	repast_hpc/matrix.h
+	repast_hpc/mpi_constants.h
+	repast_hpc/spatial_math.h
+	repast_hpc/WeightedRandomSelector.h
+	)
+
+set(rhpc_src
+	repast_hpc/AgentId.cpp
+	repast_hpc/AgentId.h
+	repast_hpc/AgentImporterExporter.cpp
+	repast_hpc/AgentImporterExporter.h
+	repast_hpc/AgentRequest.cpp
+	repast_hpc/AgentRequest.h
+	repast_hpc/AgentStatus.cpp
+	repast_hpc/AgentStatus.h
+	repast_hpc/BaseGrid.h
+	repast_hpc/CartesianTopology.cpp
+	repast_hpc/CartesianTopology.h
+	repast_hpc/Context.h
+	repast_hpc/DataSet.h
+	repast_hpc/DirectedVertex.h
+	repast_hpc/Edge.h
+	repast_hpc/Graph.cpp
+	repast_hpc/Graph.h
+	repast_hpc/Grid.h
+	repast_hpc/Grid2DQuery.h
+	repast_hpc/GridComponents.cpp
+	repast_hpc/GridComponents.h
+	repast_hpc/GridDimensions.cpp
+	repast_hpc/GridDimensions.h
+	repast_hpc/initialize_random.cpp
+	repast_hpc/initialize_random.h
+	repast_hpc/io.cpp
+	repast_hpc/io.h
+	repast_hpc/logger.cpp
+	repast_hpc/logger.h
+	repast_hpc/matrix.h
+	repast_hpc/Moore2DGridQuery.h
+	repast_hpc/mpi_constants.h
+	repast_hpc/MultipleOccupancy.h
+	repast_hpc/NCDataSet.cpp
+	repast_hpc/NCDataSet.h
+	repast_hpc/NCDataSetBuilder.cpp
+	repast_hpc/NCDataSetBuilder.h
+	repast_hpc/NCDataSource.h
+	repast_hpc/NCReducibleDataSource.h
+	repast_hpc/NetworkBuilder.cpp
+	repast_hpc/NetworkBuilder.h
+	repast_hpc/Point.h
+	repast_hpc/Projection.h
+	repast_hpc/Properties.cpp
+	repast_hpc/Properties.h
+	repast_hpc/Random.cpp
+	repast_hpc/Random.h
+	repast_hpc/ReducibleDataSource.h
+	repast_hpc/RelativeLocation.cpp
+	repast_hpc/RelativeLocation.h
+	repast_hpc/RelativeLocationMap.h
+	repast_hpc/RepastErrors.cpp
+	repast_hpc/RepastErrors.h
+	repast_hpc/RepastProcess.cpp
+	repast_hpc/RepastProcess.h
+	repast_hpc/Schedule.cpp
+	repast_hpc/Schedule.h
+	repast_hpc/SharedBaseGrid.cpp
+	repast_hpc/SharedBaseGrid.h
+	repast_hpc/SharedContext.cpp
+	repast_hpc/SharedContext.h
+	repast_hpc/SharedContinuousSpace.h
+	repast_hpc/SharedDiscreteSpace.h
+	repast_hpc/SharedNetwork.h
+	repast_hpc/SharedSpaces.h
+	repast_hpc/SingleOccupancy.h
+	repast_hpc/Spaces.h
+	repast_hpc/spatial_math.cpp
+	repast_hpc/spatial_math.h
+	repast_hpc/SRManager.cpp
+	repast_hpc/SRManager.h
+	repast_hpc/SVDataSet.cpp
+	repast_hpc/SVDataSet.h
+	repast_hpc/SVDataSetBuilder.cpp
+	repast_hpc/SVDataSetBuilder.h
+	repast_hpc/SVDataSource.h
+	repast_hpc/TDataSource.h
+	repast_hpc/UndirectedVertex.h
+	repast_hpc/Utilities.cpp
+	repast_hpc/Utilities.h
+	repast_hpc/ValueLayer.cpp
+	repast_hpc/ValueLayer.h
+	repast_hpc/Variable.cpp
+	repast_hpc/Variable.h
+	repast_hpc/Vertex.h
+	repast_hpc/VN2DGridQuery.h
+	repast_hpc/WeightedRandomSelector.h
+)
+
+set(relogo_headers
+	relogo/AbstractRelogoAgent.h
+	relogo/AgentSet.h
+	relogo/Observer.h
+	relogo/Patch.h
+	relogo/RandomMove.h
+	relogo/RelogoAgent.h
+	relogo/RelogoContinuousSpaceAdder.h
+	relogo/RelogoDiscreteSpaceAdder.h
+	relogo/RelogoErrors.h
+	relogo/RelogoLink.h
+	relogo/RelogoSharedContinuousSpace.h
+	relogo/RelogoSharedDiscreteSpace.h
+	relogo/SimulationRunner.h
+	relogo/SimulationRunnerPlus.h
+	relogo/Turtle.h
+	relogo/WorldCreator.h
+	relogo/WorldDefinition.h
+	relogo/agent_set_functions.h
+	relogo/creators.h
+	relogo/grid_types.h
+	relogo/relogo.h
+	relogo/utility.h
+	)
+
+set (relogo_src
+	relogo/AbstractRelogoAgent.cpp
+	relogo/AbstractRelogoAgent.h
+	relogo/agent_set_functions.h
+	relogo/AgentSet.cpp
+	relogo/AgentSet.h
+	relogo/creators.cpp
+	relogo/creators.h
+	relogo/grid_types.h
+	relogo/Observer.cpp
+	relogo/Observer.h
+	relogo/Patch.cpp
+	relogo/Patch.h
+	relogo/RandomMove.cpp
+	relogo/RandomMove.h
+	relogo/relogo.h
+	relogo/RelogoAgent.cpp
+	relogo/RelogoAgent.h
+	relogo/RelogoContinuousSpaceAdder.cpp
+	relogo/RelogoContinuousSpaceAdder.h
+	relogo/RelogoDiscreteSpaceAdder.cpp
+	relogo/RelogoDiscreteSpaceAdder.h
+	relogo/RelogoErrors.h
+	relogo/RelogoLink.cpp
+	relogo/RelogoLink.h
+	relogo/RelogoSharedContinuousSpace.h
+	relogo/RelogoSharedDiscreteSpace.h
+	relogo/SimulationRunner.h
+	relogo/SimulationRunnerPlus.h
+	relogo/Turtle.cpp
+	relogo/Turtle.h
+	relogo/utility.cpp
+	relogo/utility.h
+	relogo/WorldCreator.cpp
+	relogo/WorldCreator.h
+	relogo/WorldDefinition.cpp
+	relogo/WorldDefinition.h
+)
+
+set (rumor_src
+	rumor/main.cpp
+	rumor/RumorModel.cpp
+	rumor/RumorModel.h
+)
+
+set (zombie_src
+	zombie/AgentPackage.h
+	zombie/Human.cpp
+	zombie/Human.h
+	zombie/InfectionSum.cpp
+	zombie/InfectionSum.h
+	zombie/main.cpp
+	zombie/Zombie.cpp
+	zombie/Zombie.h
+	zombie/ZombieObserver.cpp
+	zombie/ZombieObserver.h
+)
+
+set (version 2.3.0)
+set (rhpc_lib_name repast_hpc)
+set (relogo_lib_name relogo)
+
+find_package(Boost 1.54.0 REQUIRED COMPONENTS system filesystem mpi serialization)
+include_directories(${Boost_INCLUDE_DIR})
+link_directories(${Boost_LIB_DIR})
+
+set (NETCDF_CXX "YES")
+find_package(NetCDF REQUIRED)
+include_directories(NETCDF_INCLUDES)
+
+find_package(CURL REQUIRED)
+
+find_package(MPI REQUIRED)
+
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${MPI_CXX_COMPILE_FLAGS} -std=c++11")
+include_directories(${MPI_CXX_INCLUDE_PATH})
+
+add_library(${rhpc_lib_name} SHARED ${rhpc_src})
+set_target_properties(${rhpc_lib_name} PROPERTIES OUTPUT_NAME ${rhpc_lib_name}-${version})
+target_link_libraries(${rhpc_lib_name} ${Boost_LIBRARIES} ${NETCDF_LIBRARIES} ${CURL_LIBRARIES} ${MPI_LIBRARIES})
+
+add_library(${relogo_lib_name} SHARED ${relogo_src})
+target_include_directories(${relogo_lib_name} PUBLIC .)
+set_target_properties(${relogo_lib_name} PROPERTIES OUTPUT_NAME ${relogo_lib_name}-${version})
+add_dependencies(${relogo_lib_name} ${rhpc_lib_name})
+target_link_libraries(${relogo_lib_name} ${Boost_LIBRARIES} ${NETCDF_LIBRARIES} ${CURL_LIBRARIES} ${MPI_LIBRARIES} ${rhpc_lib_name})
+
+set (rumor_exec rumor_model)
+add_executable(${rumor_exec} ${rumor_src})
+set_target_properties(${rumor_exec} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ./bin/rumor)
+file (COPY ../src/rumor/config.props ../src/rumor/model.props DESTINATION ./bin/rumor) 
+target_include_directories(${rumor_exec} PUBLIC .)
+add_dependencies(${rumor_exec} ${rhpc_lib_name})
+target_link_libraries(${rumor_exec} ${Boost_LIBRARIES} ${NETCDF_LIBRARIES} ${CURL_LIBRARIES} ${MPI_LIBRARIES} ${rhpc_lib_name})
+
+set (zombie_exec zombie_model)
+add_executable(${zombie_exec} ${zombie_src})
+set_target_properties( ${zombie_exec} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ./bin/zombies)
+file (COPY ../src/zombie/config.props ../src/zombie/model.props ../src/zombie/model-1cpu.props DESTINATION ./bin/zombies) 
+target_include_directories(${zombie_exec} PUBLIC .)
+add_dependencies(${zombie_exec} ${rhpc_lib_name} ${relogo_lib_name})
+target_link_libraries(${zombie_exec} ${Boost_LIBRARIES} ${NETCDF_LIBRARIES} ${CURL_LIBRARIES} ${MPI_LIBRARIES} ${rhpc_lib_name} ${relogo_lib_name})
+
+set(DEST_DIR "${CMAKE_INSTALL_PREFIX}")
+
+INSTALL(TARGETS ${rhpc_lib_name} ${relogo_lib_name}
+	DESTINATION lib)
+
+INSTALL(FILES ${rhpc_headers}
+	DESTINATION include/repast_hpc)
+
+INSTALL(FILES ${relogo_headers}
+	DESTINATION include/relogo)
+
+set(exec_prefix ${CMAKE_INSTALL_PREFIX})
+CONFIGURE_FILE("repast_hpc.pc.in" "repast_hpc.pc" @ONLY)
+
+INSTALL(FILES "${CMAKE_BINARY_DIR}/repast_hpc.pc"
+	        DESTINATION lib/pkgconfig)
diff -Naur repast_hpc-2.3.0/src/relogo/SimulationRunnerPlus.h repast_hpc-2.3.0~patched/src/relogo/SimulationRunnerPlus.h
--- repast_hpc-2.3.0/src/relogo/SimulationRunnerPlus.h	1969-12-31 19:00:00.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/relogo/SimulationRunnerPlus.h	2019-01-29 10:34:29.000000000 -0500
@@ -0,0 +1,194 @@
+/*
+ *   Repast for High Performance Computing (Repast HPC)
+ *
+ *   Copyright (c) 2010 Argonne National Laboratory
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with
+ *   or without modification, are permitted provided that the following
+ *   conditions are met:
+ *
+ *     Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *     Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the documentation
+ *     and/or other materials provided with the distribution.
+ *
+ *     Neither the name of the Argonne National Laboratory nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE TRUSTEES OR
+ *   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ *   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *  SimulationRunnerPlus.h
+ *
+ *  Created on: Sep 30, 2014
+ *      Author: Jon Cline <jon.c.cline@gmail.com>
+ */
+
+#ifndef SIMULATIONRUNNERPLUS_HPP_
+#define SIMULATIONRUNNERPLUS_HPP_
+
+#include <vector>
+
+#include <boost/mpi/communicator.hpp>
+
+#include "boost/algorithm/string/split.hpp"
+#include "boost/algorithm/string/classification.hpp"
+
+#include "boost/scoped_ptr.hpp"
+
+#include "repast_hpc/Properties.h"
+#include "repast_hpc/RepastProcess.h"
+
+#include "RelogoLink.h"
+#include "WorldCreator.h"
+#include "WorldDefinition.h"
+
+namespace repast {
+
+  namespace relogo {
+
+    using namespace boost;
+    using namespace boost::algorithm;
+
+    /**
+     * Runs a Relogo simulation.
+     *
+     * @tparam ObserverType the type of Observer to create. This type must
+     * extend relogo::Observer.
+     * @tparam PatchType the type of Patches to create. This must extend
+     * relogo::Patch.
+     */
+    template<typename ObserverType, typename PatchType>
+    class SimulationRunnerPlus {
+    protected:
+      boost::mpi::communicator* comm;
+      std::unique_ptr<Properties> mCp_props;
+      std::unique_ptr<ObserverType> mCp_obs;
+
+    public:
+      /**
+       * Creates a SimulationRunner.
+       *
+       * @param world handle to mpi communication
+       */
+      SimulationRunnerPlus(boost::mpi::communicator* communicator): comm(communicator) {
+	mCp_props.reset(new Properties());
+      }
+
+      /**
+       * Creates the simulation using the properties defined in props.
+       * The properties file must have the following properties defined:
+       *
+       * <ul>
+       * <li>min.x the minimum integer x coordinate of the world
+       * <li>min.y the minimum integer y coordinate of the world
+       * <li>max.x the maximum integer x coordinate of the world
+       * <li>max.h the maximum integer y coordinate of the world
+       * <li>grid.buffer the size of the grid and space buffers
+       * <li>proc.per.x the number of processes to assign to the world's x dimension. proc.per.x
+       * multiplied by proc.per.y must equal the number processes that the simulation will run on
+       * <li>proc.per.y the number of processes to assign to the world's y dimension. proc.per.x
+       * multiplied by proc.per.y must equal the number processes that the simulation will run on
+       * <li>stop.at the tick at which to stop the simulation
+       *
+       * This will create an Observer of the specified type and populate the world
+       * with Patches of the specified type. It will then call setup(props) on that Observer
+       * implementation and start the simulation schedule which will call the Observer's
+       * go method each tick.
+       *
+       * @param props a properties file containing the properties mentioned above
+       */
+      void setup(Properties& props);
+
+      /**
+       * Runs the simulation.
+       */
+      void run();
+
+      /**
+       * @returns reference to properties (const)
+       */
+      const repast::Properties& getProperties() {
+	return *mCp_props;
+      }
+
+      /**
+       * @returns handle to Observer
+       */
+      ObserverType* getObserver() {
+	return mCp_obs.get();
+      }
+    };
+
+    template<typename ObserverType, typename PatchType>
+    void SimulationRunnerPlus<ObserverType,PatchType>::setup(Properties& props) {
+      *mCp_props = props;
+
+      int minX = strToInt(mCp_props->getProperty("min.x"));
+      int minY = strToInt(mCp_props->getProperty("min.y"));
+      int maxX = strToInt(mCp_props->getProperty("max.x"));
+      int maxY = strToInt(mCp_props->getProperty("max.y"));
+      int buffer = strToInt(mCp_props->getProperty("grid.buffer"));
+
+      bool worldIsWrapped = true;
+      if(mCp_props->contains("non.toroidal")) worldIsWrapped = false;
+
+      RelogoLinkContentManager rlcm;
+
+      WorldDefinition def(minX, minY, maxX, maxY, worldIsWrapped, buffer);
+
+      // Networks
+      if(mCp_props->contains("DirectedNetworks")){
+	std::string netList = mCp_props->getProperty("DirectedNetworks");
+	std::vector<std::string> directedNetworks;
+	split(directedNetworks, netList, boost::is_any_of(" ,"), boost::token_compress_on);
+	for(unsigned int i = 0; i < directedNetworks.size(); i++){
+	  if(directedNetworks[i].compare("default") == 0) def.defineNetwork(true, &rlcm);
+	  else                                	          def.defineNetwork(directedNetworks[i], true, &rlcm);
+	}
+      }
+
+      if(mCp_props->contains("UndirectedNetworks")){
+	std::string netList = mCp_props->getProperty("UndirectedNetworks");
+	std::vector<std::string> undirectedNetworks;
+	split(undirectedNetworks, netList, boost::is_any_of(" ,"), boost::token_compress_on);
+	for(unsigned int i = 0; i < undirectedNetworks.size(); i++){
+	  if(undirectedNetworks[i].compare("default") == 0) def.defineNetwork(false, &rlcm);
+	  else                                              def.defineNetwork(undirectedNetworks[i], false, &rlcm);
+	}
+      }
+
+      int processesPerX = strToInt(mCp_props->getProperty("proc.per.x"));
+      int processesPerY = strToInt(mCp_props->getProperty("proc.per.y"));
+      std::vector<int> procsPerDim;
+      procsPerDim.push_back(processesPerX);
+      procsPerDim.push_back(processesPerY);
+
+      WorldCreator creator(comm);
+      mCp_obs.reset(creator.createWorld<ObserverType, PatchType> (def, procsPerDim));
+      mCp_obs->_setup(*mCp_props);
+    }
+
+    template<typename ObserverType, typename PatchType>
+    void SimulationRunnerPlus<ObserverType,PatchType>::run() {
+      RepastProcess::instance()->getScheduleRunner().run();
+    }
+  }
+
+}
+
+#endif /* SIMULATIONRUNNERPLUS_HPP_ */
diff -Naur repast_hpc-2.3.0/src/repast_hpc/Schedule.cpp repast_hpc-2.3.0~patched/src/repast_hpc/Schedule.cpp
--- repast_hpc-2.3.0/src/repast_hpc/Schedule.cpp	2018-12-05 11:53:35.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/repast_hpc/Schedule.cpp	2019-02-09 17:54:45.000000000 -0500
@@ -179,20 +179,34 @@
 	endEvents.push_back(func);
 }
 
+void ScheduleRunner::execNextEvent() {
+        all_reduce(*comm, localNextTick, globalNextTick, boost::mpi::minimum<double>());
+        if (localNextTick == globalNextTick)
+                schedule_.execute();
+        nextTick();
+}
+
 void ScheduleRunner::run() {
 	//Timer timer;
 	while (go) {
-		//timer.start();
-		all_reduce(*comm, localNextTick, globalNextTick, boost::mpi::minimum<double>());//&localNextTick, &globalNextTick, 1, MPI::DOUBLE, MPI::MIN);
-		//Log4CL::instance()->get_logger("root").log(INFO, "schedule idle, time: " + boost::lexical_cast<std::string>(timer.stop()));
-		if (localNextTick == globalNextTick)
-			schedule_.execute();
-		nextTick();
+                execNextEvent();
 	}
 	// execute end events
+	// for (size_t i = 0; i < endEvents.size(); i++) {
+	// 	(*endEvents[i])();
+	// }
+	end();
+}
+
+void ScheduleRunner::init() {
+	go = true;                    // reset go
+	schedule_ = Schedule();       // Create a new schedule
+}
+
+void ScheduleRunner::end() {
+	// execute end events
 	for (size_t i = 0; i < endEvents.size(); i++) {
 		(*endEvents[i])();
 	}
 }
-
 }
diff -Naur repast_hpc-2.3.0/src/repast_hpc/Schedule.h repast_hpc-2.3.0~patched/src/repast_hpc/Schedule.h
--- repast_hpc-2.3.0/src/repast_hpc/Schedule.h	2018-12-05 11:53:35.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/repast_hpc/Schedule.h	2019-02-09 17:51:53.000000000 -0500
@@ -301,6 +301,25 @@
 		return schedule_.getCurrentTick();
 	}
 
+ 	/**
+	 * Executes the next event. The function adds support to interactive
+	 * execution of a simulation.
+	 * <br>
+	 * 2014-02-05 added by jcline@mitre.org
+	 */
+	void execNextEvent();
+
+	/**
+	 * Gets whether the simulation is currently running.
+	 * <br>
+	 * 2014-02-05 added by jcline@mitre.org
+	 *
+	 * @return whether the simulation is currently running
+	 */
+	bool isRunning() {
+	  return go;
+	}
+ 
 	/**
 	 * Stops the simulation.
 	 */
@@ -314,6 +333,20 @@
 	const Schedule& schedule() {
 		return schedule_;
 	}
+  
+  	/**
+	 * Initializes the simulation schedule.
+	 * <br>
+	 * 2014-09-26 added by jcline@mitre.org
+	 */
+	void init();
+  
+  	/**
+	 * Ends the simulation.
+	 * <br>
+	 * 2019-02-09 added by jcline@mitre.org
+	 */
+	void end();
 };
 
 }
diff -Naur repast_hpc-2.3.0/src/repast_hpc.pc.in repast_hpc-2.3.0~patched/src/repast_hpc.pc.in
--- repast_hpc-2.3.0/src/repast_hpc.pc.in	1969-12-31 19:00:00.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/repast_hpc.pc.in	2019-01-12 20:50:28.000000000 -0500
@@ -0,0 +1,10 @@
+prefix=@DEST_DIR@
+exec_prefix=@exec_prefix@
+libdir=${exec_prefix}/lib
+includedir=${exec_prefix}/include
+
+Name: Repast HPC
+Description:
+Version: @version@
+Libs: -L${libdir} -lrepast_hpc-@version@ -lrelogo-@version@
+Cflags: -I${includedir}
diff -Naur repast_hpc-2.3.0/src/zombie/ZombieObserver.cpp repast_hpc-2.3.0~patched/src/zombie/ZombieObserver.cpp
--- repast_hpc-2.3.0/src/zombie/ZombieObserver.cpp	2018-12-05 11:53:35.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/zombie/ZombieObserver.cpp	2019-01-27 20:51:13.000000000 -0500
@@ -66,7 +66,10 @@
   if (_rank == 0) {
     Log4CL::instance()->get_logger("root").log(INFO, "TICK BEGINS: " + boost::lexical_cast<string>(RepastProcess::instance()->getScheduleRunner().currentTick()));
   }
-  synchronize<AgentPackage>(*this, *this, *this, RepastProcess::USE_LAST_OR_USE_CURRENT);
+  // only synchronize if running on more than one processor!
+  if (RepastProcess::communicator()->size() > 1) {
+    synchronize<AgentPackage>(*this, *this, *this, RepastProcess::USE_LAST_OR_USE_CURRENT);
+  }
 
   AgentSet<Zombie> zombies;
   get(zombies);
diff -Naur repast_hpc-2.3.0/src/zombie/model-1cpu.props repast_hpc-2.3.0~patched/src/zombie/model-1cpu.props
--- repast_hpc-2.3.0/src/zombie/model-1cpu.props	1969-12-31 19:00:00.000000000 -0500
+++ repast_hpc-2.3.0~patched/src/zombie/model-1cpu.props	2019-01-27 20:42:27.000000000 -0500
@@ -0,0 +1,22 @@
+#random.seed = 1284067381
+stop.at = 10
+
+# per process
+human.count = 500;
+zombie.count = 5;
+
+# world definition props
+min.x = -100
+min.y = -100
+max.x = 99
+max.y = 99 
+grid.buffer = 1
+
+# these must multiply to total number of processes
+proc.per.x = 1
+proc.per.y = 1
+
+# named random number distributions
+distribution.zombie_move = int_uniform, 0, 2
+
+
